// burstTestProducer.js
import { Kafka } from "kafkajs";

const kafka = new Kafka({
  clientId: "burst-test-producer",
  brokers: ["localhost:9092"],
});

const producer = kafka.producer();

const topics = [
  "input-topic-1",
  "input-topic-2",
  "input-topic-3",
  "input-topic-4",
  "input-topic-5",
];

// Create one JSON record
function createRecord(id, topic) {
  return {
    key: `key-${id % 50}`, // reuse some keys to test dedup collisions
    value: JSON.stringify({
      id,
      message: `Message ${id} for ${topic}`,
      timestamp: new Date().toISOString(),
    }),
  };
}

async function sendRecords(topic, withGap = false) {
  console.log(
    `\n🚀 Starting test for ${topic} | Gap: ${withGap ? "10s" : "none"}`
  );

  // 1️⃣ Send 1000 unique messages
  const uniqueMessages = Array.from({ length: 1000 }, (_, i) =>
    createRecord(i, topic)
  );

  await producer.send({
    topic,
    messages: uniqueMessages,
  });

  console.log(`✅ Sent 1000 unique messages to ${topic}`);

  // Optional 10s gap before duplicates
  if (withGap) {
    console.log("⏳ Waiting 10 seconds before sending duplicates...");
    await new Promise((r) => setTimeout(r, 10_000));
  }

  // 2️⃣ Send duplicates
  await producer.send({
    topic,
    messages: uniqueMessages,
  });

  console.log(
    `♻️ Sent 1000 duplicate messages to ${topic} ${withGap ? "(after delay)" : "(immediately)"}`
  );
}

async function runTests() {
  await producer.connect();

  // SCENARIO 1: No gap (cache dedup)
  for (const topic of topics) {
    await sendRecords(topic, false);
  }

  // SCENARIO 2: 10s gap (global dedup)
  for (const topic of topics) {
    await sendRecords(topic, true);
  }

  await producer.disconnect();
  console.log("\n🏁 All scenarios completed!");
}

runTests().catch((err) => {
  console.error("❌ Error producing messages:", err);
  process.exit(1);
});
